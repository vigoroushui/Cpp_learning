# 1. 算法库中有哪些类型的操作？什么是函数对象？
有四个类型的操作，分别是：
- 非修改式序列操作：不改变容器的内容，如find()、for_each()等。
- 修改式序列操作：可以修改容器中的内容，如transform()、random_shuffle()、copy等。
- 排序和相关操作：包括各种排序函数等，如sort()等。
- 通用数字运算：计算两个容器的内部乘积等。

函数对象：定义了调用操作符()的类对象。当用该对象调用此操作符时，其表现形式如同普通函数调用一般。
- 函数对象可以有自己的状态。我们可以在类中定义状态变量，这样一个函数对象在多次的调用中可以共享这个状态；
- 函数对象有自己特有的类型。我们可以传递相应的类型作为参数来实例化相应的模板，比如说带参数的函数形参。
# 2. 容器、迭代器、算法之间的关系是怎样的？他们是如何结合在一起的？
每个容器都有专属的迭代器，而算法通过迭代器对容器中的元素进行操作。迭代器在stl中用来将算法和容器联系起来，起着一种胶着剂的作用。

迭代器是种更高层次的抽象，它使得算法独立于容器,这使得算法独立于类型。
算法通过操作容器对应的迭代器，就可以间接地操作容器中的元素。而不需要关注容器的内部细节。
# 3. 什么是迭代器失效问题？该问题是如何产生的？怎样避免产生迭代器失效问题？
迭代器失效指迭代器指向错误的元素或者无效的内存空间。

迭代器失效的产生原因和解决方法要分为三种情况来讨论：
1. 底层实现以数组型数据结构实现的vector、deque序列式容器：该数据结构的元素事分配在连续的内存中，insert和erase操作都会使删除点和插入点之后的元素挪位置。所以，插入点和删除掉之后的迭代器全部失效，也就是说insert(*iter)或者erase(*iter))，然后再执行iter++是没有意义的。解决方法：erase(*iter)的返回值是下一个有效迭代器的值,即iter=cont.erase(iter)。或者用remove-erase惯用法。
2. 链表型数据结构：对于list型的数据结构，使用了不连续分配的内存，删除运算使指向删除位置的迭代器失效，但是不会失效其他迭代器。解决办法两种，erase(*iter)会返回下一个有效迭代器的值，或者erase(iter++)。
3. 树形数据结构：使用红黑树来存储数据，插入不会使得任何迭代器失效；删除运算使指向删除位置的迭代器失效，但是不会失效其他迭代器。erase迭代器只是被删元素的迭代器失效，但是返回值为void，所以要采用erase(iter++)的方式删除迭代器。

# 4. 什么是回调函数，注册回调函数，执行回调函数？(掌握std::bind用法,非常重要)
> std::bind的实现原理阅读材料
	> http://www.cnblogs.com/xusd-null/p/3698969.html
    > https://www.tuicool.com/articles/iMZ7ba

> function + bind的救赎 
    > https://blog.csdn.net/myan/article/details/5928531

注册回调简单解释就是一个高层调用底层，底层再回过头来调用高层，这个过程就叫注册回调， 连接高层和底层就叫注册回调函数。高层程序C1调用底层程序C2，而在底层程序C2 又调用了高层程序C2的callback函数，那么这个callback函数对于高层程序C1来说就是回调函数。 在设计模式中这个方式叫回调模式。

回调函数就是一个通过函数指针调用的函数。注册回调函数是提供函数实现的一方在初始化的时候，将回调函数的函数指针注册给调用者。执行回调函数就是当特定的事件或条件发生的时候，调用者使用函数指针调用回调函数对事件进行处理。

具体看`bind.cc` 

# 5. 了解std::allocator的用法之后,实现自定义的Vector类
```cpp
接口形式：
    template<typename T>
    class Vector
    {
    public:
        Vector();
        ~Vector();
        
        void push_back(const T &); 
        void pop_back();    
        
        int size();
        int capacity();
    private:
        void reallocate();//重新分配内存,动态扩容要用的
    private:    
        static std::allocator<T> _alloc;
        
        T * _start;      //指向数组中的第一个元素
        T * _finish; //指向最后一个实际元素之后的那个元素
        T * _end_of_storage;        //指向数组本身之后的位置
    };
    
    Vector模型
     ______________________________
    |_|_|_|_|_|____________________|
     ↑         ↑                    ↑
   _start   _finish            _end_of_storage
```
# 6. 结合STL源码阅读《STL源码剖析》第二章内容理解std::allocator的实现